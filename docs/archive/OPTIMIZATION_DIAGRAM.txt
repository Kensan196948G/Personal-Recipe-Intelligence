# N+1 Query Optimization - Visual Diagrams

## Before vs After Optimization

### BEFORE: N+1 Query Problem (301 queries for 100 recipes)

```
API Request: GET /api/v1/recipes/?limit=100
│
└─> Query 1: SELECT * FROM recipes LIMIT 100
    │
    ├─> For Recipe #1:
    │   ├─> Query 2: SELECT * FROM ingredients WHERE recipe_id=1
    │   ├─> Query 3: SELECT * FROM steps WHERE recipe_id=1
    │   └─> Query 4: SELECT * FROM recipe_tags WHERE recipe_id=1
    │
    ├─> For Recipe #2:
    │   ├─> Query 5: SELECT * FROM ingredients WHERE recipe_id=2
    │   ├─> Query 6: SELECT * FROM steps WHERE recipe_id=2
    │   └─> Query 7: SELECT * FROM recipe_tags WHERE recipe_id=2
    │
    ├─> For Recipe #3:
    │   ├─> Query 8: SELECT * FROM ingredients WHERE recipe_id=3
    │   ├─> Query 9: SELECT * FROM steps WHERE recipe_id=3
    │   └─> Query 10: SELECT * FROM recipe_tags WHERE recipe_id=3
    │
    └─> ... (continues for all 100 recipes)

TOTAL: 1 + (100 × 3) = 301 queries
TIME: ~950ms
```

### AFTER: Optimized with selectinload() (4 queries for 100 recipes)

```
API Request: GET /api/v1/recipes/?limit=100
│
├─> Query 1: SELECT * FROM recipes LIMIT 100
│   Returns: [Recipe#1, Recipe#2, ..., Recipe#100]
│
├─> Query 2: SELECT * FROM ingredients WHERE recipe_id IN (1,2,...,100)
│   Returns: All ingredients for all recipes at once
│
├─> Query 3: SELECT * FROM steps WHERE recipe_id IN (1,2,...,100)
│   Returns: All steps for all recipes at once
│
└─> Query 4: SELECT * FROM recipe_tags WHERE recipe_id IN (1,2,...,100)
    Returns: All tags for all recipes at once

TOTAL: 4 queries
TIME: ~85ms
IMPROVEMENT: 75x fewer queries, 11x faster
```

## Data Flow Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    CLIENT (Browser)                      │
│                                                          │
│  GET /api/v1/recipes/?skip=0&limit=50&tags=japanese     │
└─────────────────────┬───────────────────────────────────┘
                      │ HTTP Request
                      ↓
┌─────────────────────────────────────────────────────────┐
│                  FastAPI Router                          │
│  File: backend/api/routers/recipes.py                   │
│                                                          │
│  • Validate query parameters (skip, limit, tags)        │
│  • Parse tag filter (comma-separated)                   │
│  • Inject database session                              │
└─────────────────────┬───────────────────────────────────┘
                      │ Call service method
                      ↓
┌─────────────────────────────────────────────────────────┐
│                  Recipe Service                          │
│  File: backend/services/recipe_service.py               │
│                                                          │
│  • Business logic layer                                 │
│  • Control eager loading (with_relations=True)          │
│  • Get total count for pagination                       │
└─────────────────────┬───────────────────────────────────┘
                      │ Call repository method
                      ↓
┌─────────────────────────────────────────────────────────┐
│                 Recipe Repository                        │
│  File: backend/repositories/recipe_repository.py        │
│                                                          │
│  • get_by_tags(tags, skip, limit, with_relations=True)  │
│  • Add selectinload() for eager loading                 │
│  • Optimize query with JOIN and IN clauses              │
└─────────────────────┬───────────────────────────────────┘
                      │ 4 optimized queries
                      ↓
┌─────────────────────────────────────────────────────────┐
│                   SQLAlchemy ORM                         │
│                                                          │
│  Query 1: SELECT recipes WHERE tag IN (...)             │
│  Query 2: SELECT ingredients WHERE recipe_id IN (...)   │
│  Query 3: SELECT steps WHERE recipe_id IN (...)         │
│  Query 4: SELECT recipe_tags WHERE recipe_id IN (...)   │
└─────────────────────┬───────────────────────────────────┘
                      │ SQL queries
                      ↓
┌─────────────────────────────────────────────────────────┐
│                   SQLite Database                        │
│  File: data/recipes.db                                  │
│                                                          │
│  Tables: recipes, ingredients, steps, recipe_tags       │
│  Indexes: recipe_id, name, normalized_name              │
└─────────────────────┬───────────────────────────────────┘
                      │ Result sets
                      ↓
┌─────────────────────────────────────────────────────────┐
│              SQLAlchemy Object Assembly                  │
│                                                          │
│  • Map query results to Recipe objects                  │
│  • Attach ingredients to recipes                        │
│  • Attach steps to recipes                              │
│  • Attach tags to recipes                               │
│  • No lazy loading triggers                             │
└─────────────────────┬───────────────────────────────────┘
                      │ Recipe objects with relations
                      ↓
┌─────────────────────────────────────────────────────────┐
│                  Pydantic Serialization                  │
│  File: backend/schemas/recipe.py                        │
│                                                          │
│  • Validate data types                                  │
│  • Convert to JSON-serializable format                  │
│  • Add pagination metadata (total, skip, limit)         │
└─────────────────────┬───────────────────────────────────┘
                      │ JSON response
                      ↓
┌─────────────────────────────────────────────────────────┐
│                    CLIENT (Browser)                      │
│                                                          │
│  {                                                       │
│    "items": [...],  // 50 recipes with all relations    │
│    "total": 234,    // Total count for pagination       │
│    "skip": 0,                                            │
│    "limit": 50                                           │
│  }                                                       │
└─────────────────────────────────────────────────────────┘
```

## Query Execution Timeline

### Before Optimization (Sequential N+1 Queries)

```
Time →
0ms    |===============| Query 1: SELECT recipes (10ms)
10ms   |==| Query 2: SELECT ingredients WHERE recipe_id=1 (2ms)
12ms   |==| Query 3: SELECT steps WHERE recipe_id=1 (2ms)
14ms   |==| Query 4: SELECT tags WHERE recipe_id=1 (2ms)
16ms   |==| Query 5: SELECT ingredients WHERE recipe_id=2 (2ms)
18ms   |==| Query 6: SELECT steps WHERE recipe_id=2 (2ms)
20ms   |==| Query 7: SELECT tags WHERE recipe_id=2 (2ms)
...
950ms  Done (301 queries total)
```

### After Optimization (Parallel-Ready Queries)

```
Time →
0ms    |===============| Query 1: SELECT recipes (10ms)
10ms   |=================| Query 2: SELECT all ingredients IN (...) (18ms)
10ms   |===============| Query 3: SELECT all steps IN (...) (15ms)
10ms   |==============| Query 4: SELECT all tags IN (...) (14ms)
28ms   Done (4 queries total, some overlapping)
```

## Database Query Comparison

### BEFORE: Multiple Separate Queries

```sql
-- Query 1: Get recipes
SELECT * FROM recipes LIMIT 100;

-- Query 2-101: Get ingredients (executed 100 times)
SELECT * FROM ingredients WHERE recipe_id = 1;
SELECT * FROM ingredients WHERE recipe_id = 2;
SELECT * FROM ingredients WHERE recipe_id = 3;
...
SELECT * FROM ingredients WHERE recipe_id = 100;

-- Query 102-201: Get steps (executed 100 times)
SELECT * FROM steps WHERE recipe_id = 1;
SELECT * FROM steps WHERE recipe_id = 2;
...

-- Query 202-301: Get tags (executed 100 times)
SELECT * FROM recipe_tags WHERE recipe_id = 1;
SELECT * FROM recipe_tags WHERE recipe_id = 2;
...

TOTAL: 301 queries
```

### AFTER: Batch Queries with IN Clause

```sql
-- Query 1: Get recipes
SELECT * FROM recipes LIMIT 100;
-- Returns IDs: [1, 2, 3, ..., 100]

-- Query 2: Get ALL ingredients at once
SELECT * FROM ingredients
WHERE recipe_id IN (1, 2, 3, ..., 100);

-- Query 3: Get ALL steps at once
SELECT * FROM steps
WHERE recipe_id IN (1, 2, 3, ..., 100);

-- Query 4: Get ALL tags at once
SELECT * FROM recipe_tags
WHERE recipe_id IN (1, 2, 3, ..., 100);

TOTAL: 4 queries
```

## Memory Usage Comparison

### BEFORE: Multiple Round-trips

```
┌────────────────────────────────────────┐
│        Application Memory              │
│                                        │
│  Recipe#1 → [waiting for ingredients] │
│           ↓ DB round-trip              │
│  Recipe#1 → [ingredients loaded]      │
│           ↓ DB round-trip              │
│  Recipe#1 → [steps loaded]            │
│           ↓ DB round-trip              │
│  Recipe#1 → [tags loaded] ✓           │
│                                        │
│  Recipe#2 → [waiting for ingredients] │
│           ↓ DB round-trip × 3          │
│  ...                                   │
└────────────────────────────────────────┘

Total round-trips: 300
Network overhead: High
Memory efficiency: Low (partial objects)
```

### AFTER: Bulk Loading

```
┌────────────────────────────────────────┐
│        Application Memory              │
│                                        │
│  Recipe#1 → [empty]                   │
│  Recipe#2 → [empty]                   │
│  Recipe#3 → [empty]                   │
│  ...                                   │
│  Recipe#100 → [empty]                 │
│           ↓ 3 DB round-trips           │
│  All ingredients → Map to recipes     │
│  All steps → Map to recipes           │
│  All tags → Map to recipes            │
│           ↓                            │
│  Recipe#1 → [fully loaded] ✓          │
│  Recipe#2 → [fully loaded] ✓          │
│  Recipe#3 → [fully loaded] ✓          │
│  ...                                   │
└────────────────────────────────────────┘

Total round-trips: 3
Network overhead: Low
Memory efficiency: High (bulk loading)
```

## Code Pattern Comparison

### BEFORE: Lazy Loading (Bad)

```python
# repository.py
def get_all(skip=0, limit=100):
    return db.query(Recipe).offset(skip).limit(limit).all()

# Usage
recipes = repo.get_all(limit=100)
for recipe in recipes:
    # This triggers N queries!
    for ingredient in recipe.ingredients:  # Query per recipe
        print(ingredient.name)
    for step in recipe.steps:              # Query per recipe
        print(step.description)
    for tag in recipe.tags:                # Query per recipe
        print(tag.name)

# Result: 1 + 100 + 100 + 100 = 301 queries
```

### AFTER: Eager Loading (Good)

```python
# repository.py
def get_all(skip=0, limit=100, with_relations=True):
    query = db.query(Recipe)
    if with_relations:
        query = query.options(
            selectinload(Recipe.ingredients),
            selectinload(Recipe.steps),
            selectinload(Recipe.tags),
        )
    return query.offset(skip).limit(limit).all()

# Usage
recipes = repo.get_all(limit=100, with_relations=True)
for recipe in recipes:
    # No additional queries!
    for ingredient in recipe.ingredients:  # Already loaded
        print(ingredient.name)
    for step in recipe.steps:              # Already loaded
        print(step.description)
    for tag in recipe.tags:                # Already loaded
        print(tag.name)

# Result: 4 queries total
```

## Batch Insert Comparison

### BEFORE: Individual Inserts

```python
# Creating a recipe with 10 ingredients
recipe = Recipe(name="Test Recipe")
db.add(recipe)
db.commit()  # 1 query

for ingredient_data in ingredients:
    ingredient = Ingredient(recipe_id=recipe.id, **ingredient_data)
    db.add(ingredient)
    db.commit()  # 10 queries (one per ingredient)

# Total: 11 queries
# Time: ~50ms
```

### AFTER: Bulk Insert

```python
# Creating a recipe with 10 ingredients
recipe = Recipe(name="Test Recipe")
db.add(recipe)
db.flush()  # Get ID without committing

# Bulk create all ingredients
ingredients = [
    Ingredient(recipe_id=recipe.id, **data)
    for data in ingredients
]
db.bulk_save_objects(ingredients)  # 1 query for all

db.commit()

# Total: 2 queries
# Time: ~5ms
# Improvement: 10x faster
```

## Performance Metrics Visualization

```
Query Count Comparison (100 recipes):
Before: ████████████████████████████████████████ 301 queries
After:  █ 4 queries

Response Time Comparison (100 recipes):
Before: ████████████████████████████ 950ms
After:  ███ 85ms

Database Load Comparison:
Before: ████████████████████████████████████████ 100%
After:  █ 1.3%

Memory Efficiency:
Before: ██████████████████ Low (partial loading)
After:  ████████████████████████████ High (bulk loading)
```

## Scaling Comparison

```
Number of Recipes vs Query Count:

Recipes │ Before  │ After │ Improvement
────────┼─────────┼───────┼────────────
   10   │    31   │   4   │   87.1%
   50   │   151   │   4   │   97.4%
  100   │   301   │   4   │   98.7%
  500   │  1501   │   4   │   99.7%
 1000   │  3001   │   4   │   99.9%

Notice: Query count AFTER is constant regardless of data size!
```

## Summary of Optimizations

```
┌─────────────────────────────────────────────────────┐
│              OPTIMIZATION TECHNIQUES                 │
├─────────────────────────────────────────────────────┤
│                                                      │
│  1. Eager Loading (selectinload)                    │
│     • Loads related data in separate queries        │
│     • Uses IN clauses for efficiency                │
│     • Prevents N+1 query problem                    │
│                                                      │
│  2. Batch Operations (bulk_save_objects)            │
│     • Inserts multiple records in one query         │
│     • Reduces database round-trips                  │
│     • 10-50x faster for bulk inserts                │
│                                                      │
│  3. Pagination (skip + limit + count)               │
│     • Limits data returned per request              │
│     • Provides total count for UI                   │
│     • Consistent performance regardless of size     │
│                                                      │
│  4. Relation Control (with_relations parameter)     │
│     • Option to load relations or not               │
│     • Lightweight queries when relations not needed │
│     • Full data when needed for display             │
│                                                      │
│  5. Query Optimization (indexes + joins)            │
│     • Indexed foreign keys                          │
│     • Efficient JOIN operations                     │
│     • Normalized ingredient names                   │
│                                                      │
└─────────────────────────────────────────────────────┘
```

## Key Takeaways

```
✓ Use selectinload() for one-to-many relationships
✓ Use bulk_save_objects() for batch inserts
✓ Always implement pagination (skip + limit)
✓ Provide total count for pagination UI
✓ Add with_relations parameter for flexibility
✓ Monitor query counts in development
✓ Target: 4 queries for list operations
✓ Keep API responses under 200ms
```

---

For implementation details, see:
- QUICK_REFERENCE.md (practical examples)
- PERFORMANCE_OPTIMIZATION_REPORT.md (full analysis)
- N+1_OPTIMIZATION_INDEX.md (complete documentation index)
